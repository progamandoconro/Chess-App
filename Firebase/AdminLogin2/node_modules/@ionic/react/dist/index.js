'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var loader = require('@ionic/core/loader');
var React = _interopDefault(require('react'));
var tslib_1 = require('tslib');
var ReactDom = _interopDefault(require('react-dom'));
var core = require('@ionic/core');
var reactRouter = require('react-router');
var reactRouterDom = require('react-router-dom');
var ionicons = require('ionicons');
var icons = require('ionicons/icons');

function attachEventProps(node, newProps, oldProps = {}) {
    const className = getClassName(node.classList, newProps, oldProps);
    if (className) {
        node.className = className;
    }
    Object.keys(newProps).forEach(name => {
        if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {
            return;
        }
        if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {
            const eventName = name.substring(2);
            const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
            if (!isCoveredByReact(eventNameLc)) {
                syncEvent(node, eventNameLc, newProps[name]);
            }
        }
        else {
            node[name] = newProps[name];
        }
    });
}
function getClassName(classList, newProps, oldProps) {
    // map the classes to Maps for performance
    const currentClasses = arrayToMap(classList);
    const incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);
    const oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);
    const finalClassNames = [];
    // loop through each of the current classes on the component
    // to see if it should be a part of the classNames added
    currentClasses.forEach((currentClass) => {
        if (incomingPropClasses.has(currentClass)) {
            // add it as its already included in classnames coming in from newProps
            finalClassNames.push(currentClass);
            incomingPropClasses.delete(currentClass);
        }
        else if (!oldPropClasses.has(currentClass)) {
            // add it as it has NOT been removed by user
            finalClassNames.push(currentClass);
        }
    });
    incomingPropClasses.forEach(s => finalClassNames.push(s));
    return finalClassNames.join(' ');
}
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isCoveredByReact(eventNameSuffix, doc = document) {
    const eventName = 'on' + eventNameSuffix;
    let isSupported = eventName in doc;
    if (!isSupported) {
        const element = doc.createElement('div');
        element.setAttribute(eventName, 'return;');
        isSupported = typeof element[eventName] === 'function';
    }
    return isSupported;
}
function syncEvent(node, eventName, newEventHandler) {
    const eventStore = node.__events || (node.__events = {});
    const oldEventHandler = eventStore[eventName];
    // Remove old listener so they don't double up.
    if (oldEventHandler) {
        node.removeEventListener(eventName, oldEventHandler);
    }
    // Bind new listener.
    node.addEventListener(eventName, eventStore[eventName] = function handler(e) {
        newEventHandler.call(this, e);
    });
}
function arrayToMap(arr) {
    const map = new Map();
    arr.forEach((s) => map.set(s, s));
    return map;
}

const IonicContext = /*@__PURE__*/ React.createContext({
    getConfig: () => { },
    setConfig: () => { },
    platform: undefined
});

const useIonicConfig = () => {
    const value = React.useContext(IonicContext);
    const config = value.getConfig() || {};
    const hook = [config, value.setConfig];
    return hook;
};

const dashToPascalCase = (str) => str.toLowerCase().split('-').map(segment => segment.charAt(0).toUpperCase() + segment.slice(1)).join('');
function generateUniqueId() {
    return ([1e7].toString() + -1e3.toString() + -4e3.toString() + -8e3.toString() + -1e11.toString()).replace(/[018]/g, function (c) {
        const random = crypto.getRandomValues(new Uint8Array(1));
        return (c ^ random[0] & 15 >> c / 4).toString(16);
    });
}

function createReactComponent(tagName, attributeValues = []) {
    const displayName = dashToPascalCase(tagName);
    class ReactComponent extends React.Component {
        constructor(props) {
            super(props);
        }
        static get displayName() {
            return displayName;
        }
        componentDidMount() {
            this.componentWillReceiveProps(this.props);
        }
        componentWillReceiveProps(props) {
            const node = ReactDom.findDOMNode(this);
            attachEventProps(node, props, this.props);
        }
        render() {
            const _a = this.props, { children, forwardedRef } = _a, cProps = tslib_1.__rest(_a, ["children", "forwardedRef"]);
            const propsWithoutAttributeValues = Object.keys(cProps).reduce((oldValue, key) => {
                if (attributeValues.indexOf(key) === -1) {
                    oldValue[key] = cProps[key];
                }
                return oldValue;
            }, {});
            return React.createElement(tagName, Object.assign({}, propsWithoutAttributeValues, { ref: forwardedRef }), children);
        }
    }
    function forwardRef(props, ref) {
        return React.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
    }
    forwardRef.displayName = displayName;
    return React.forwardRef(forwardRef);
}

// ionicons
const IonIcon = /*@__PURE__*/ createReactComponent('ion-icon', ['icon']);
// /*@__PURE__*/createReactComponent
const IonTabBarInner = /*@__PURE__*/ createReactComponent('ion-tab-bar');
const IonRouterOutletInner = /*@__PURE__*/ createReactComponent('ion-router-outlet');
const IonBackButtonInner = /*@__PURE__*/ createReactComponent('ion-back-button');
const IonTab = /*@__PURE__*/ createReactComponent('ion-tab');
const IonTabButton = /*@__PURE__*/ createReactComponent('ion-tab-button');
const IonAnchor = /*@__PURE__*/ createReactComponent('ion-anchor');
const IonAppInner = /*@__PURE__*/ createReactComponent('ion-app');
const IonAvatar = /*@__PURE__*/ createReactComponent('ion-avatar');
const IonBackdrop = /*@__PURE__*/ createReactComponent('ion-backdrop');
const IonBadge = /*@__PURE__*/ createReactComponent('ion-badge');
const IonButton = /*@__PURE__*/ createReactComponent('ion-button');
const IonButtons = /*@__PURE__*/ createReactComponent('ion-buttons');
const IonCard = /*@__PURE__*/ createReactComponent('ion-card');
const IonCardContent = /*@__PURE__*/ createReactComponent('ion-card-content');
const IonCardHeader = /*@__PURE__*/ createReactComponent('ion-card-header');
const IonCardSubtitle = /*@__PURE__*/ createReactComponent('ion-card-subtitle');
const IonCardTitle = /*@__PURE__*/ createReactComponent('ion-card-title');
const IonCheckbox = /*@__PURE__*/ createReactComponent('ion-checkbox');
const IonCol = /*@__PURE__*/ createReactComponent('ion-col');
const IonContent = /*@__PURE__*/ createReactComponent('ion-content');
const IonChip = /*@__PURE__*/ createReactComponent('ion-chip');
const IonDatetime = /*@__PURE__*/ createReactComponent('ion-datetime');
const IonFab = /*@__PURE__*/ createReactComponent('ion-fab');
const IonFabButton = /*@__PURE__*/ createReactComponent('ion-fab-button');
const IonFabList = /*@__PURE__*/ createReactComponent('ion-fab-list');
const IonFooter = /*@__PURE__*/ createReactComponent('ion-footer');
const IonGrid = /*@__PURE__*/ createReactComponent('ion-grid');
const IonHeader = /*@__PURE__*/ createReactComponent('ion-header');
const IonImg = /*@__PURE__*/ createReactComponent('ion-img');
const IonInfiniteScroll = /*@__PURE__*/ createReactComponent('ion-infinite-scroll');
const IonInput = /*@__PURE__*/ createReactComponent('ion-input');
const IonItem = /*@__PURE__*/ createReactComponent('ion-item');
const IonItemDivider = /*@__PURE__*/ createReactComponent('ion-item-divider');
const IonItemGroup = /*@__PURE__*/ createReactComponent('ion-item-group');
const IonItemOption = /*@__PURE__*/ createReactComponent('ion-item-option');
const IonItemOptions = /*@__PURE__*/ createReactComponent('ion-item-options');
const IonItemSliding = /*@__PURE__*/ createReactComponent('ion-item-sliding');
const IonLabel = /*@__PURE__*/ createReactComponent('ion-label');
const IonList = /*@__PURE__*/ createReactComponent('ion-list');
const IonListHeader = /*@__PURE__*/ createReactComponent('ion-list-header');
const IonMenu = /*@__PURE__*/ createReactComponent('ion-menu');
const IonMenuButton = /*@__PURE__*/ createReactComponent('ion-menu-button');
const IonMenuToggle = /*@__PURE__*/ createReactComponent('ion-menu-toggle');
const IonNote = /*@__PURE__*/ createReactComponent('ion-note');
const IonPicker = /*@__PURE__*/ createReactComponent('ion-picker');
const IonPickerColumn = /*@__PURE__*/ createReactComponent('ion-picker-column');
const IonNav = /*@__PURE__*/ createReactComponent('ion-nav');
const IonProgressBar = /*@__PURE__*/ createReactComponent('ion-progress-bar');
const IonRadio = /*@__PURE__*/ createReactComponent('ion-radio');
const IonRadioGroup = /*@__PURE__*/ createReactComponent('ion-radio-group');
const IonRange = /*@__PURE__*/ createReactComponent('ion-range');
const IonRefresher = /*@__PURE__*/ createReactComponent('ion-refresher');
const IonRefresherContent = /*@__PURE__*/ createReactComponent('ion-refresher-content');
const IonReorder = /*@__PURE__*/ createReactComponent('ion-reorder');
const IonReorderGroup = /*@__PURE__*/ createReactComponent('ion-reorder-group');
const IonRippleEffect = /*@__PURE__*/ createReactComponent('ion-ripple-effect');
const IonRow = /*@__PURE__*/ createReactComponent('ion-row');
const IonSearchbar = /*@__PURE__*/ createReactComponent('ion-searchbar');
const IonSegment = /*@__PURE__*/ createReactComponent('ion-segment');
const IonSegmentButton = /*@__PURE__*/ createReactComponent('ion-segment-button');
const IonSelect = /*@__PURE__*/ createReactComponent('ion-select');
const IonSelectOption = /*@__PURE__*/ createReactComponent('ion-select-option');
const IonSelectPopover = /*@__PURE__*/ createReactComponent('ion-select-popover');
const IonSkeletonText = /*@__PURE__*/ createReactComponent('ion-skeleton-text');
const IonSlide = /*@__PURE__*/ createReactComponent('ion-slide');
const IonSlides = /*@__PURE__*/ createReactComponent('ion-slides');
const IonSpinner = /*@__PURE__*/ createReactComponent('ion-spinner');
const IonSplitPane = /*@__PURE__*/ createReactComponent('ion-split-pane');
const IonText = /*@__PURE__*/ createReactComponent('ion-text');
const IonTextarea = /*@__PURE__*/ createReactComponent('ion-textarea');
const IonThumbnail = /*@__PURE__*/ createReactComponent('ion-thumbnail');
const IonTitle = /*@__PURE__*/ createReactComponent('ion-title');
const IonToggle = /*@__PURE__*/ createReactComponent('ion-toggle');
const IonToolbar = /*@__PURE__*/ createReactComponent('ion-toolbar');
const IonVirtualScroll = /*@__PURE__*/ createReactComponent('ion-virtual-scroll');

class Platform {
    constructor() { }
    /**
     * @returns returns true/false based on platform.
     * @description
     * Depending on the platform the user is on, `is(platformName)` will
     * return `true` or `false`. Note that the same app can return `true`
     * for more than one platform name. For example, an app running from
     * an iPad would return `true` for the platform names: `mobile`,
     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
     * from Cordova then `cordova` would be true, and if it was running
     * from a web browser on the iPad then `mobileweb` would be `true`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     if (this.platform.is('ios')) {
     *       // This will only print when on iOS
     *       console.log('I am an iOS device!');
     *     }
     *   }
     * }
     * ```
     *
     * | Platform Name   | Description                        |
     * |-----------------|------------------------------------|
     * | android         | on a device running Android.       |
     * | cordova         | on a device running Cordova.       |
     * | ios             | on a device running iOS.           |
     * | ipad            | on an iPad device.                 |
     * | iphone          | on an iPhone device.               |
     * | phablet         | on a phablet device.               |
     * | tablet          | on a tablet device.                |
     * | electron        | in Electron on a desktop device.   |
     * | pwa             | as a PWA app.                      |
     * | mobile          | on a mobile device.                |
     * | mobileweb       | on a mobile device in a browser.   |
     * | desktop         | on a desktop device.               |
     * | hybrid          | is a cordova or capacitor app.     |
     *
     */
    is(platformName) {
        return core.isPlatform(window, platformName);
    }
    /**
     * @returns the array of platforms
     * @description
     * Depending on what device you are on, `platforms` can return multiple values.
     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
     * it would return `mobile`, `ios`, and `iphone`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     // This will print an array of the current platforms
     *     console.log(this.platform.platforms());
     *   }
     * }
     * ```
     */
    platforms() {
        return core.getPlatforms(window);
    }
    /**
   * Returns if this app is using right-to-left language direction or not.
   * We recommend the app's `index.html` file already has the correct `dir`
   * attribute value set, such as `<html dir="ltr">` or `<html dir="rtl">`.
   * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
   */
    get isRTL() {
        return document.dir === 'rtl';
    }
    /**
   * Get the query string parameter
   */
    getQueryParam(key) {
        return readQueryParam(window.location.href, key);
    }
    /**
     * Returns `true` if the app is in landscape mode.
     */
    isLandscape() {
        return !this.isPortrait();
    }
    /**
    * Returns `true` if the app is in portait mode.
    */
    isPortrait() {
        return window.matchMedia && window.matchMedia('(orientation: portrait)').matches;
    }
    testUserAgent(expression) {
        const nav = window.navigator;
        return !!(nav && nav.userAgent && nav.userAgent.indexOf(expression) >= 0);
    }
    /**
   * Get the current url.
   */
    url() {
        return window.location.href;
    }
    /**
     * Gets the width of the platform's viewport using `window.innerWidth`.
     */
    width() {
        return window.innerWidth;
    }
    /**
     * Gets the height of the platform's viewport using `window.innerHeight`.
     */
    height() {
        return window.innerHeight;
    }
}
const readQueryParam = (url, key) => {
    key = key.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    const regex = new RegExp('[\\?&]' + key + '=([^&#]*)');
    const results = regex.exec(url);
    return results ? decodeURIComponent(results[1].replace(/\+/g, ' ')) : null;
};

function getConfig() {
    const coreConfig = getCoreConfig();
    const config = Array.from(coreConfig.m).reduce((obj, [key, value]) => {
        obj[key] = value;
        return obj;
    }, {});
    return config;
}
function setConfig(config) {
    const coreConfig = getCoreConfig();
    coreConfig.reset(config);
}
function getCoreConfig() {
    if (typeof window !== 'undefined') {
        const Ionic = window.Ionic;
        if (Ionic && Ionic.config) {
            return window.Ionic.config;
        }
    }
    return null;
}

class IonApp extends React.Component {
    constructor(props) {
        super(props);
        const ionicPlatform = new Platform();
        this.state = {
            getConfig: getConfig,
            setConfig: setConfig,
            platform: ionicPlatform
        };
    }
    render() {
        return (React.createElement(IonicContext.Provider, { value: this.state },
            React.createElement(IonAppInner, null, this.props.children)));
    }
}

function createControllerComponent(displayName, controller) {
    const dismissEventName = `on${displayName}DidDismiss`;
    return class ReactControllerComponent extends React.Component {
        constructor(props) {
            super(props);
            this.id = generateUniqueId();
        }
        static get displayName() {
            return displayName;
        }
        async componentDidMount() {
            const { isOpen } = this.props;
            if (isOpen) {
                this.present();
            }
        }
        async componentDidUpdate(prevProps) {
            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
                this.present(prevProps);
            }
            if (this.controller && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
                await this.controller.dismiss();
            }
        }
        async present(prevProps) {
            const _a = this.props, { isOpen, onDidDismiss } = _a, cProps = tslib_1.__rest(_a, ["isOpen", "onDidDismiss"]);
            const elementProps = Object.assign({}, cProps, { [dismissEventName]: onDidDismiss });
            this.controller = await controller.create(Object.assign({}, elementProps));
            attachEventProps(this.controller, elementProps, prevProps);
            this.controller.present();
        }
        render() {
            return null;
        }
    };
}

const IonAlert = /*@__PURE__*/ createControllerComponent('IonAlert', core.alertController);

const IonLoading = /*@__PURE__*/ createControllerComponent('IonLoading', core.loadingController);

const IonToast = /*@__PURE__*/ createControllerComponent('IonToast', core.toastController);

function createOverlayComponent(displayName, controller) {
    const dismissEventName = `on${displayName}DidDismiss`;
    return class ReactOverlayComponent extends React.Component {
        constructor(props) {
            super(props);
            this.el = document.createElement('div');
        }
        static get displayName() {
            return displayName;
        }
        componentDidMount() {
            if (this.props.isOpen) {
                this.present();
            }
        }
        async componentDidUpdate(prevProps) {
            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
                this.present(prevProps);
            }
            if (this.controller && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
                await this.controller.dismiss();
            }
        }
        async present(prevProps) {
            const _a = this.props, { children, isOpen, onDidDismiss = () => { } } = _a, cProps = tslib_1.__rest(_a, ["children", "isOpen", "onDidDismiss"]);
            const elementProps = Object.assign({}, cProps, { [dismissEventName]: onDidDismiss });
            this.controller = await controller.create(Object.assign({}, elementProps, { component: this.el, componentProps: {} }));
            attachEventProps(this.controller, elementProps, prevProps);
            this.controller.present();
        }
        render() {
            return ReactDom.createPortal(this.props.children, this.el);
        }
    };
}

const IonActionSheet = /*@__PURE__*/ createOverlayComponent('IonActionSheet', core.actionSheetController);

const IonModal = /*@__PURE__*/ createOverlayComponent('IonModal', core.modalController);

const IonPopover = /*@__PURE__*/ createOverlayComponent('IonPopover', core.popoverController);

const IonPageInternal = (_a) => {
    var { children, forwardedRef, className } = _a, props = tslib_1.__rest(_a, ["children", "forwardedRef", "className"]);
    return (React.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, props), children));
};
function forwardRef(props, ref) {
    return React.createElement(IonPageInternal, Object.assign({}, props, { forwardedRef: ref }));
}
forwardRef.displayName = 'IonPage';
const IonPage = /*@__PURE__*/ React.forwardRef(forwardRef);

class TabBar extends React.Component {
    constructor(props) {
        super(props);
        this.onTabButtonClick = (e) => {
            const targetUrl = (this.state.activeTab === e.detail.tab) ?
                this.state.tabs[e.detail.tab].originalHref :
                this.state.tabs[e.detail.tab].currentHref;
            this.props.history.push(targetUrl);
        };
        this.renderChild = (activeTab) => (child) => {
            if (child != null && typeof child === 'object' && child.props && child.type === IonTabButton) {
                const href = (child.props.tab === activeTab) ? this.props.location.pathname : (this.state.tabs[child.props.tab].currentHref);
                return React.cloneElement(child, {
                    href,
                    onIonTabButtonClick: this.onTabButtonClick
                });
            }
            return null;
        };
        const tabActiveUrls = {};
        React.Children.forEach(this.props.children, (child) => {
            if (child != null && typeof child === 'object' && child.props && child.type === IonTabButton) {
                tabActiveUrls[child.props.tab] = {
                    originalHref: child.props.href,
                    currentHref: child.props.href
                };
            }
        });
        this.state = {
            activeTab: null,
            tabs: tabActiveUrls
        };
    }
    static getDerivedStateFromProps(props, state) {
        const activeTab = Object.keys(state.tabs)
            .find(key => {
            const href = state.tabs[key].originalHref;
            return props.location.pathname.startsWith(href);
        });
        if (!activeTab || (activeTab === state.activeTab && state.tabs[activeTab].currentHref === props.location.pathname)) {
            return null;
        }
        return {
            activeTab,
            tabs: Object.assign({}, state.tabs, { [activeTab]: {
                    originalHref: state.tabs[activeTab].originalHref,
                    currentHref: props.location.pathname
                } })
        };
    }
    render() {
        return (React.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: this.state.activeTab }), React.Children.map(this.props.children, this.renderChild(this.state.activeTab))));
    }
}
const IonTabBar = /*@__PURE__*/ reactRouter.withRouter(TabBar);

function generateUniqueId$1() {
    return ([1e7].toString() + -1e3.toString() + -4e3.toString() + -8e3.toString() + -1e11.toString()).replace(/[018]/g, function (c) {
        const random = crypto.getRandomValues(new Uint8Array(1));
        return (c ^ random[0] & 15 >> c / 4).toString(16);
    });
}

const IonLifeCycleContext = React.createContext({
    onIonViewWillEnter: () => { },
    ionViewWillEnter: () => { },
    onIonViewDidEnter: () => { },
    ionViewDidEnter: () => { },
    onIonViewWillLeave: () => { },
    ionViewWillLeave: () => { },
    onIonViewDidLeave: () => { },
    ionViewDidLeave: () => { }
});
class DefaultIonLifeCycleContext {
    onIonViewWillEnter(callback) {
        this.ionViewWillEnterCallback = callback;
    }
    ionViewWillEnter() {
        if (this.ionViewWillEnterCallback) {
            this.ionViewWillEnterCallback();
        }
    }
    onIonViewDidEnter(callback) {
        this.ionViewDidEnterCallback = callback;
    }
    ionViewDidEnter() {
        if (this.ionViewDidEnterCallback) {
            this.ionViewDidEnterCallback();
        }
    }
    onIonViewWillLeave(callback) {
        this.ionViewWillLeaveCallback = callback;
    }
    ionViewWillLeave() {
        if (this.ionViewWillLeaveCallback) {
            this.ionViewWillLeaveCallback();
        }
    }
    onIonViewDidLeave(callback) {
        this.ionViewDidLeaveCallback = callback;
    }
    ionViewDidLeave() {
        if (this.ionViewDidLeaveCallback) {
            this.ionViewDidLeaveCallback();
        }
        this.componentCanBeDestroyed();
    }
    onComponentCanBeDestroyed(callback) {
        this.componentCanBeDestroyedCallback = callback;
    }
    componentCanBeDestroyed() {
        if (this.componentCanBeDestroyedCallback) {
            this.componentCanBeDestroyedCallback();
        }
    }
}

class ViewInternal extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            ref: null
        };
    }
    componentDidMount() {
        const { forwardedRef } = this.props;
        this.setState({ ref: forwardedRef });
        if (forwardedRef && forwardedRef.current) {
            forwardedRef.current.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));
            forwardedRef.current.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));
            forwardedRef.current.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));
            forwardedRef.current.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));
        }
    }
    componentWillUnmount() {
        const { forwardedRef } = this.props;
        if (forwardedRef && forwardedRef.current) {
            forwardedRef.current.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));
            forwardedRef.current.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));
            forwardedRef.current.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));
            forwardedRef.current.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));
        }
    }
    ionViewWillEnterHandler() {
        this.context.ionViewWillEnter();
    }
    ionViewDidEnterHandler() {
        this.context.ionViewDidEnter();
    }
    ionViewWillLeaveHandler() {
        this.context.ionViewWillLeave();
    }
    ionViewDidLeaveHandler() {
        this.context.ionViewDidLeave();
    }
    render() {
        const _a = this.props, { className, children, forwardedRef } = _a, rest = tslib_1.__rest(_a, ["className", "children", "forwardedRef"]);
        const { ref } = this.state;
        return (React.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, rest), ref && children));
    }
}
ViewInternal.contextType = IonLifeCycleContext;
function forwardRef$1(props, ref) {
    return React.createElement(ViewInternal, Object.assign({ forwardedRef: ref }, props));
}
forwardRef$1.displayName = 'View';
const View = /*@__PURE__*/ React.forwardRef(forwardRef$1);

const NavContext = /*@__PURE__*/ React.createContext({
    viewStacks: {},
    hideView: () => { navContextNotFoundError(); },
    goBack: () => { navContextNotFoundError(); },
    setupIonRouter: () => { navContextNotFoundError(); },
    removeViewStack: () => { navContextNotFoundError(); },
    renderChild: () => { navContextNotFoundError(); },
    transitionView: () => { navContextNotFoundError(); }
});
function navContextNotFoundError() {
    console.error('IonRouter not found, did you add it to the app?');
}

const withIonLifeCycle = (WrappedComponent) => {
    return class IonLifeCycle extends React.Component {
        constructor(props) {
            super(props);
            this.componentRef = React.createRef();
        }
        componentDidMount() {
            this.context.onIonViewWillEnter(() => {
                if (this.componentRef.current.ionViewWillEnter) {
                    this.componentRef.current.ionViewWillEnter();
                }
            });
            this.context.onIonViewDidEnter(() => {
                if (this.componentRef.current.ionViewDidEnter) {
                    this.componentRef.current.ionViewDidEnter();
                }
            });
            this.context.onIonViewWillLeave(() => {
                if (this.componentRef.current.ionViewWillLeave) {
                    this.componentRef.current.ionViewWillLeave();
                }
            });
            this.context.onIonViewDidLeave(() => {
                if (this.componentRef.current.ionViewDidLeave) {
                    this.componentRef.current.ionViewDidLeave();
                }
            });
        }
        render() {
            return (React.createElement(IonLifeCycleContext.Consumer, null, context => {
                this.context = context;
                return (React.createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props)));
            }));
        }
    };
};

const useIonViewWillEnter = (callback) => {
    const value = React.useContext(IonLifeCycleContext);
    value.onIonViewWillEnter(callback);
};
const useIonViewDidEnter = (callback) => {
    const value = React.useContext(IonLifeCycleContext);
    value.onIonViewDidEnter(callback);
};
const useIonViewWillLeave = (callback) => {
    const value = React.useContext(IonLifeCycleContext);
    value.onIonViewWillLeave(callback);
};
const useIonViewDidLeave = (callback) => {
    const value = React.useContext(IonLifeCycleContext);
    value.onIonViewDidLeave(callback);
};

class ViewItemManager extends React.Component {
    constructor(props) {
        super(props);
        this.ionLifeCycleContext = new DefaultIonLifeCycleContext();
        this._isMounted = false;
        this.state = {
            show: true
        };
        this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {
            if (!this.props.mount) {
                if (this._isMounted) {
                    this.setState({
                        show: false
                    }, () => {
                        this.context.hideView(this.props.id);
                    });
                }
            }
        });
    }
    componentDidMount() {
        this._isMounted = true;
    }
    componentWillUnmount() {
        this._isMounted = false;
    }
    render() {
        const { show } = this.state;
        return (React.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children));
    }
}
// TODO: treeshake
ViewItemManager.contextType = NavContext;

class IonRouterOutlet extends React.Component {
    constructor(props) {
        super(props);
        this.containerEl = React.createRef();
        this.id = this.props.id || generateUniqueId$1();
    }
    componentDidMount() {
        this.context.setupIonRouter(this.id, this.props.children, this.containerEl.current);
    }
    componentWillUnmount() {
        this.context.removeViewStack(this.id);
    }
    render() {
        return (React.createElement(NavContext.Consumer, null, context => {
            this.context = context;
            const viewStack = context.viewStacks[this.id];
            const activeId = viewStack ? viewStack.activeId : '';
            const views = (viewStack || { views: [] }).views.filter(x => x.show);
            return (React.createElement(IonRouterOutletInner, { "data-id": this.id, ref: this.containerEl }, views.map((item) => {
                let props = {};
                if (item.id === activeId) {
                    props = {
                        'className': ' ion-page-invisible'
                    };
                }
                return (React.createElement(ViewItemManager, { id: item.id, key: item.key, mount: item.mount },
                    React.createElement(View, Object.assign({ ref: item.ref }, props), this.context.renderChild(item))));
            })));
        }));
    }
}

const hostStyles = {
    display: 'flex',
    position: 'absolute',
    top: '0',
    left: '0',
    right: '0',
    bottom: '0',
    flexDirection: 'column',
    width: '100%',
    height: '100%',
    contain: 'layout size style'
};
const tabsInner = {
    position: 'relative',
    flex: 1,
    contain: 'layout size style'
};
class IonTabs extends React.Component {
    render() {
        let outlet;
        let tabBar;
        React.Children.forEach(this.props.children, (child) => {
            if (child == null || typeof child !== 'object' || !child.hasOwnProperty('type')) {
                return;
            }
            if (child.type === IonRouterOutlet) {
                outlet = child;
            }
            if (child.type === IonTabBar) {
                tabBar = child;
            }
        });
        return (React.createElement("div", { style: hostStyles },
            tabBar.props.slot === 'top' ? tabBar : null,
            React.createElement("div", { style: tabsInner, className: "tabs-inner" }, outlet),
            tabBar.props.slot === 'bottom' ? tabBar : null));
    }
}

class IonBackButton extends React.Component {
    constructor() {
        super(...arguments);
        this.clickButton = (e) => {
            e.stopPropagation();
            this.context.goBack(this.props.defaultHref);
        };
    }
    render() {
        return (React.createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props)));
    }
}
IonBackButton.contextType = NavContext;

class IonNavManager extends React.Component {
    constructor(props) {
        super(props);
        this.goBack = (defaultHref) => {
            const { view: leavingView } = this.findViewInfoByLocation(this.props.location, this.state.viewStacks);
            if (leavingView) {
                const { view: enteringView } = this.findViewInfoById(leavingView.prevId, this.state.viewStacks);
                if (enteringView) {
                    this.props.history.replace(enteringView.routeData.match.url, { direction: 'back' });
                }
                else {
                    this.props.history.replace(defaultHref, { direction: 'back' });
                }
            }
            else {
                this.props.history.replace(defaultHref, { direction: 'back' });
            }
        };
        this.state = {
            viewStacks: {},
            hideView: this.hideView.bind(this),
            setupIonRouter: this.setupIonRouter.bind(this),
            removeViewStack: this.removeViewStack.bind(this),
            renderChild: this.renderChild.bind(this),
            goBack: this.goBack.bind(this),
            transitionView: this.transitionView.bind(this)
        };
    }
    componentWillMount() {
        this.listenUnregisterCallback = this.props.history.listen(this.historyChange.bind(this));
    }
    hideView(viewId) {
        const viewStacks = Object.assign({}, this.state.viewStacks);
        const { view } = this.findViewInfoById(viewId, viewStacks);
        if (view) {
            view.show = false;
            view.key = generateUniqueId();
            this.setState({
                viewStacks
            });
        }
    }
    historyChange(location, action) {
        this.setActiveView(location, action);
    }
    findViewInfoByLocation(location, viewStacks) {
        let view;
        let match;
        let viewStack;
        const keys = Object.keys(viewStacks);
        keys.some(key => {
            const vs = viewStacks[key];
            return vs.views.some(x => {
                match = reactRouterDom.matchPath(location.pathname, x.routeData.childProps);
                if (match) {
                    view = x;
                    viewStack = vs;
                    return true;
                }
                return false;
            });
        });
        const result = { view, viewStack, match };
        return result;
    }
    findViewInfoById(id, viewStacks) {
        let view;
        let viewStack;
        const keys = Object.keys(viewStacks);
        keys.some(key => {
            const vs = viewStacks[key];
            view = vs.views.find(x => x.id === id);
            if (view) {
                viewStack = vs;
                return true;
            }
            else {
                return false;
            }
        });
        return { view, viewStack };
    }
    setActiveView(location, action) {
        const viewStacks = Object.assign({}, this.state.viewStacks);
        const { view: enteringView, viewStack: enteringViewStack, match } = this.findViewInfoByLocation(location, viewStacks);
        let direction = location.state && location.state.direction;
        if (!enteringViewStack) {
            return;
        }
        const { view: leavingView } = this.findViewInfoById(this.activeViewId, viewStacks);
        if (leavingView && leavingView.routeData.match.url === location.pathname) {
            return;
        }
        if (enteringView) {
            /**
             * If the page is being pushed into the stack by another view,
             * record the view that originally directed to the new view for back button purposes.
             */
            if (!enteringView.show && action === 'PUSH') {
                enteringView.prevId = leavingView && leavingView.id;
            }
            enteringView.show = true;
            enteringView.mount = true;
            enteringView.routeData.match = match;
            enteringViewStack.activeId = enteringView.id;
            this.activeViewId = enteringView.id;
            if (leavingView) {
                this.prevViewId = leavingView.id;
                if (leavingView.routeData.match.params.tab === enteringView.routeData.match.params.tab) {
                    if (action === 'PUSH') {
                        direction = direction || 'forward';
                    }
                    else {
                        direction = direction || 'back';
                        leavingView.mount = false;
                    }
                }
                /**
                 * Attempt to determine if the leaving view is a route redirect.
                 * If it is, take it out of the rendering phase.
                 * We assume Routes with render props are redirects, because of this users should not use
                 * the render prop for non redirects, and instead provide a component in its place.
                 */
                if (leavingView.element.type === reactRouterDom.Redirect || leavingView.element.props.render) {
                    leavingView.mount = false;
                    leavingView.show = false;
                }
            }
            this.setState({
                viewStacks
            }, () => {
                const enteringEl = enteringView.ref && enteringView.ref.current ? enteringView.ref.current : undefined;
                const leavingEl = leavingView && leavingView.ref && leavingView.ref.current ? leavingView.ref.current : undefined;
                this.transitionView(enteringEl, leavingEl, enteringViewStack.routerOutlet, direction);
            });
        }
    }
    componentWillUnmount() {
        this.listenUnregisterCallback();
    }
    setupIonRouter(id, children, routerOutlet) {
        const views = [];
        let activeId;
        React.Children.forEach(children, (child) => {
            if (child.type === reactRouterDom.Switch) {
                /**
                 * If the first child is a Switch, loop through its children to build the viewStack
                 */
                React.Children.forEach(child.props.children, (grandChild) => {
                    addView.call(this, grandChild);
                });
            }
            else {
                addView.call(this, child);
            }
        });
        this.registerViewStack(id, activeId, views, routerOutlet, this.props.location);
        function addView(child) {
            const location = this.props.history.location;
            const viewId = generateUniqueId();
            const key = generateUniqueId();
            const element = child;
            const match = reactRouterDom.matchPath(location.pathname, child.props);
            const view = {
                id: viewId,
                key,
                routeData: {
                    match,
                    childProps: child.props
                },
                element,
                mount: true,
                show: !!match,
                ref: React.createRef()
            };
            if (!!match) {
                activeId = viewId;
            }
            views.push(view);
            return activeId;
        }
    }
    registerViewStack(stack, activeId, stackItems, routerOutlet, location) {
        this.setState((prevState) => {
            const prevViewStacks = Object.assign({}, prevState.viewStacks);
            prevViewStacks[stack] = {
                activeId: activeId,
                views: stackItems,
                routerOutlet
            };
            return {
                viewStacks: prevViewStacks
            };
        }, () => {
            const { view: activeView } = this.findViewInfoById(activeId, this.state.viewStacks);
            if (activeView) {
                this.prevViewId = this.activeViewId;
                this.activeViewId = activeView.id;
                const direction = location.state && location.state.direction;
                const { view: prevView } = this.findViewInfoById(this.prevViewId, this.state.viewStacks);
                this.transitionView(activeView.ref.current, prevView && prevView.ref.current || undefined, routerOutlet, direction);
            }
        });
    }
    ;
    removeViewStack(stack) {
        const viewStacks = Object.assign({}, this.state.viewStacks);
        delete viewStacks[stack];
        this.setState({
            viewStacks
        });
    }
    renderChild(item) {
        const component = React.cloneElement(item.element, {
            computedMatch: item.routeData.match
        });
        return component;
    }
    findActiveView(views) {
        let view;
        views.some(x => {
            const match = reactRouterDom.matchPath(this.props.location.pathname, x.routeData.childProps);
            if (match) {
                view = x;
                return true;
            }
            return false;
        });
        return view;
    }
    transitionView(enteringEl, leavingEl, ionRouterOuter, direction) {
        /**
         * Super hacky workaround to make sure ionRouterOutlet is available
         * since transitionView might be called before IonRouterOutlet is fully mounted
         */
        if (ionRouterOuter && ionRouterOuter.componentOnReady) {
            this.commitView(enteringEl, leavingEl, ionRouterOuter, direction);
        }
        else {
            setTimeout(() => {
                this.transitionView(enteringEl, leavingEl, ionRouterOuter, direction);
            }, 10);
        }
    }
    async commitView(enteringEl, leavingEl, ionRouterOuter, direction) {
        await ionRouterOuter.componentOnReady();
        await ionRouterOuter.commit(enteringEl, leavingEl, {
            deepWait: true,
            duration: direction === undefined ? 0 : undefined,
            direction: direction,
            showGoBack: direction === 'forward',
            progressAnimation: false
        });
        if (leavingEl && (enteringEl !== leavingEl)) {
            /**
             *  add hidden attributes
            */
            leavingEl.classList.add('ion-page-hidden');
            leavingEl.setAttribute('aria-hidden', 'true');
        }
    }
    render() {
        return (React.createElement(NavContext.Provider, { value: this.state }, this.props.children));
    }
}
const IonNavManagerWithRouter = reactRouterDom.withRouter(IonNavManager);
IonNavManagerWithRouter.displayName = 'IonNavManager';
class IonReactRouter extends React.Component {
    render() {
        const _a = this.props, { children } = _a, props = tslib_1.__rest(_a, ["children"]);
        return (React.createElement(reactRouterDom.BrowserRouter, Object.assign({}, props),
            React.createElement(IonNavManagerWithRouter, null, children)));
    }
}

loader.defineCustomElements(window);
// Icons that are used by internal components
ionicons.addIcons({
    'ios-close': icons.close.ios,
    'md-close': icons.close.md,
    'ios-reorder': icons.reorder.ios,
    'md-reorder': icons.reorder.md,
    'ios-menu': icons.menu.ios,
    'md-menu': icons.menu.md,
    'ios-arrow-forward': icons.arrowForward.ios,
    'md-arrow-forward': icons.arrowForward.md,
    'ios-arrow-back': icons.arrowBack.ios,
    'md-arrow-back': icons.arrowBack.md,
    'ios-arrow-down': icons.arrowDown.ios,
    'md-arrow-down': icons.arrowDown.md,
    'ios-search': icons.search.ios,
    'md-search': icons.search.md,
    'ios-close-circle': icons.closeCircle.ios,
    'md-close-circle': icons.closeCircle.md,
});

exports.IonActionSheet = IonActionSheet;
exports.IonAlert = IonAlert;
exports.IonAnchor = IonAnchor;
exports.IonApp = IonApp;
exports.IonAppInner = IonAppInner;
exports.IonAvatar = IonAvatar;
exports.IonBackButton = IonBackButton;
exports.IonBackButtonInner = IonBackButtonInner;
exports.IonBackdrop = IonBackdrop;
exports.IonBadge = IonBadge;
exports.IonButton = IonButton;
exports.IonButtons = IonButtons;
exports.IonCard = IonCard;
exports.IonCardContent = IonCardContent;
exports.IonCardHeader = IonCardHeader;
exports.IonCardSubtitle = IonCardSubtitle;
exports.IonCardTitle = IonCardTitle;
exports.IonCheckbox = IonCheckbox;
exports.IonChip = IonChip;
exports.IonCol = IonCol;
exports.IonContent = IonContent;
exports.IonDatetime = IonDatetime;
exports.IonFab = IonFab;
exports.IonFabButton = IonFabButton;
exports.IonFabList = IonFabList;
exports.IonFooter = IonFooter;
exports.IonGrid = IonGrid;
exports.IonHeader = IonHeader;
exports.IonIcon = IonIcon;
exports.IonImg = IonImg;
exports.IonInfiniteScroll = IonInfiniteScroll;
exports.IonInput = IonInput;
exports.IonItem = IonItem;
exports.IonItemDivider = IonItemDivider;
exports.IonItemGroup = IonItemGroup;
exports.IonItemOption = IonItemOption;
exports.IonItemOptions = IonItemOptions;
exports.IonItemSliding = IonItemSliding;
exports.IonLabel = IonLabel;
exports.IonLifeCycleContext = IonLifeCycleContext;
exports.IonList = IonList;
exports.IonListHeader = IonListHeader;
exports.IonLoading = IonLoading;
exports.IonMenu = IonMenu;
exports.IonMenuButton = IonMenuButton;
exports.IonMenuToggle = IonMenuToggle;
exports.IonModal = IonModal;
exports.IonNav = IonNav;
exports.IonNote = IonNote;
exports.IonPage = IonPage;
exports.IonPicker = IonPicker;
exports.IonPickerColumn = IonPickerColumn;
exports.IonPopover = IonPopover;
exports.IonProgressBar = IonProgressBar;
exports.IonRadio = IonRadio;
exports.IonRadioGroup = IonRadioGroup;
exports.IonRange = IonRange;
exports.IonReactRouter = IonReactRouter;
exports.IonRefresher = IonRefresher;
exports.IonRefresherContent = IonRefresherContent;
exports.IonReorder = IonReorder;
exports.IonReorderGroup = IonReorderGroup;
exports.IonRippleEffect = IonRippleEffect;
exports.IonRouterOutlet = IonRouterOutlet;
exports.IonRouterOutletInner = IonRouterOutletInner;
exports.IonRow = IonRow;
exports.IonSearchbar = IonSearchbar;
exports.IonSegment = IonSegment;
exports.IonSegmentButton = IonSegmentButton;
exports.IonSelect = IonSelect;
exports.IonSelectOption = IonSelectOption;
exports.IonSelectPopover = IonSelectPopover;
exports.IonSkeletonText = IonSkeletonText;
exports.IonSlide = IonSlide;
exports.IonSlides = IonSlides;
exports.IonSpinner = IonSpinner;
exports.IonSplitPane = IonSplitPane;
exports.IonTab = IonTab;
exports.IonTabBar = IonTabBar;
exports.IonTabBarInner = IonTabBarInner;
exports.IonTabButton = IonTabButton;
exports.IonTabs = IonTabs;
exports.IonText = IonText;
exports.IonTextarea = IonTextarea;
exports.IonThumbnail = IonThumbnail;
exports.IonTitle = IonTitle;
exports.IonToast = IonToast;
exports.IonToggle = IonToggle;
exports.IonToolbar = IonToolbar;
exports.IonVirtualScroll = IonVirtualScroll;
exports.IonicContext = IonicContext;
exports.useIonViewDidEnter = useIonViewDidEnter;
exports.useIonViewDidLeave = useIonViewDidLeave;
exports.useIonViewWillEnter = useIonViewWillEnter;
exports.useIonViewWillLeave = useIonViewWillLeave;
exports.useIonicConfig = useIonicConfig;
exports.withIonLifeCycle = withIonLifeCycle;
